''' this files in this content are as they are in the their respective file(module)'''



```python
 # config.py
 import os
 import logging
 
 class Config:
     def __init__(self):
         self.image_source = "camera"  # or "data"
         self.gemini_api_key = os.environ.get("GEMINI_API_KEY")
         self.violation_threshold = 0.5
         self.image_dir = "violations"
         self.db_path = "violations.db"
         self.camera_index = 0
         self.input_shape = (256, 256)  # Reduced resolution for RPi [Optimization]
         self.prompt = """
             Detect traffic violations in the image.  Identify the type of violation,
             and provide bounding box coordinates (x1, y1, x2, y2) for the violating vehicle.
             Possible violation types are: "wrong_way", "clearway", "red_light", "speeding", "lane_change".
             If no violation is detected, return "no_violation".
 
             Respond with a JSON object.  The JSON object should have the following structure:
 
             {
                 "violations": [
                     {
                         "type": "violation_type",
                         "bbox": [x1, y1, x2, y2],
                         "position_description": "very detailed description of where visually",
                         "confidence": confidence_score
                     },
                     ... // more violations if any
                 ]
             }
 
             Example 1:
             {
                 "violations": [
                     {
                         "type": ...
 """
 

 # database.py
 import sqlite3
 import logging
 

 class ViolationDatabase:
     def __init__(self, db_path):
         self.conn = sqlite3.connect(db_path, check_same_thread=False)  # Allow access from multiple threads
         self.cursor = self.conn.cursor()
         self.create_tables()
         logging.info("Database connection established.")
 

     def create_tables(self):
         self.cursor.execute("""
             CREATE TABLE IF NOT EXISTS violations (
                 id INTEGER PRIMARY KEY AUTOINCREMENT,
                 timestamp TEXT NOT NULL,
                 image_path TEXT NOT NULL,
                 image_hash TEXT NOT NULL,
                 violation_type TEXT NOT NULL,
                 confidence REAL NOT NULL,
                 bbox TEXT NOT NULL,
                 position_description TEXT NOT NULL
             )
         """)
         self.cursor.execute("""
             CREATE TABLE IF NOT EXISTS processed_images (
                 image_hash TEXT PRIMARY KEY,
                 processed_at TEXT DEFAULT CURRENT_TIMESTAMP
             )
         """)
         self.conn.commit()
         logging.info("Database tables created (if not exist).")
 

     def insert_violation(self, timestamp, image_path, image_hash, violation_type, confidence, bbox, position_description):
         try:
             self.cursor.execute("""
                 INSERT INTO violations (timestamp, image_path, image_hash, violation_type, confidence, bbox, position_description)
                 VALUES (?, ?, ?, ?, ?, ?, ?)
             """, (timestamp, image_path, image_hash, violation_type, confidence, bbox, position_description))
             self.conn.commit()
             logging.info(f"Violation inserted: {violation_type}, Image: {image_path}, Hash: {image_hash}")
         except sqlite3.Error as e:
             logging.error(f"Error inserting violation: {e}")
 

     def check_image_hash(self, image_hash):
         self.cursor.execute("SELECT 1 FROM processed_images WHERE image_hash = ?", (image_hash,))
         return self.cursor.fetchone() is not None
 

     def insert_image_hash(self, image_hash):
         try:
             self.cursor.execute("INSERT INTO processed_images (image_hash) VALUES (?)", (image_hash,))
             self.conn.commit()
             logging.info(f"Image hash inserted: {image_hash}")
         except sqlite3.Error as e:
             logging.error(f"Error inserting image hash: {e}")
 

     def close(self):
         self.conn.close()
         logging.info("Database connection closed.")
 

 # detector.py
 import logging
 import os
 import cv2
 import google.generativeai as genai
 

 class ViolationDetector:
     def __init__(self, gemini_api_key, image_dir, input_shape, prompt):
         genai.configure(api_key=gemini_api_key)
         self.model = genai.GenerativeModel('gemini-pro-vision')
         self.image_dir = image_dir
         self.input_shape = input_shape
         self.prompt = prompt
         os.makedirs(self.image_dir, exist_ok=True)
         logging.info("ViolationDetector initialized.")
 

     def preprocess_image(self, image):
         """Resize the image while maintaining aspect ratio."""
         height, width = image.shape[:2]
         target_height, target_width = self.input_shape
         aspect_ratio = width / height
 

         if width > height:
             new_width = target_width
             new_height = int(target_width / aspect_ratio)
         else:
             new_height = target_height
             new_width = int(target_height * aspect_ratio)
 

         resized_image = cv2.resize(image, (new_width, new_height), interpolation=cv2.INTER_AREA)
 

         # Create a black canvas with the target size
         canvas = np.zeros((target_height, target_width, 3), dtype=np.uint8)
         # Paste the resized image onto the canvas, centering it
         y_offset = (target_height - new_height) // 2
         x_offset = (target_width - new_width) // 2
         canvas[y_offset:y_offset + new_height, x_offset:x_offset + new_width] = resized_image
         return canvas
 

     def detect_violation(self, image):
         try:
             preprocessed_image = self.preprocess_image(image)
             response = self.model.generate_content([self.prompt, preprocessed_image])
             response.raise_exception()  # Raise an exception if the API request failed
             json_string = response.text
             try:
                 data = json.loads(json_string)
                 violations = data.get("violations", [])
                 if violations:
                     return "Violation", violations
                 else:
                     return "no_violation", []
             except json.JSONDecodeError:
                 logging.error(f"JSON Decode Error: {json_string}")
                 return "Error", []
         except Exception as e:
             logging.error(f"Error detecting violation: {e}")
             return "Error", []
 

     def save_violation_image(self, image, timestamp):
         image_path = os.path.join(self.image_dir, f"{timestamp}.jpg")
         try:
             cv2.imwrite(image_path, image)
             logging.info(f"Violation image saved: {image_path}")
             return image_path
         except Exception as e:
             logging.error(f"Error saving violation image: {e}")
             return None
 

 # image_src.py
 import datetime
 import queue
 import os
 import cv2
 import logging
 from config import Config
 import threading
 import time
 import hashlib
 import numpy as np
 

 class ImageSource:
     def __init__(self, config: Config):
         self.source_type = config.image_source
         self.camera_index = config.camera_index
         self.config = config
         self.read_images_thread = None
         self.running = False
         self.image_queue = None  # Will be set in start_capture
         self.db = None
         self.data_dir = "camera_data"  # Directory to save camera frames
         os.makedirs(self.data_dir, exist_ok=True)  # Ensure directory exists
         self.capture_interval = 30  # Capture interval in seconds
         self.last_capture_time = 0  # Time of the last capture
         self.frame_count = 0  # Frame counter for skipping [Optimization]
         logging.info(f"ImageSource initialized with type: {self.source_type}")
 

     def start_capture(self, image_queue, db):
         """Start capturing images, either from camera or directory."""
         self.image_queue = image_queue
         self.running = True
         self.db = db
         logging.info("Capture started.")
         if self.source_type == "camera":
             self.capture = cv2.VideoCapture(self.camera_index)
             if not self.capture.isOpened():
                 logging.error(f"Error: Unable to open camera with index {self.camera_index}")
                 self.running = False
                 return
             # Create a thread for read_camera_frames
             self.read_images_thread = threading.Thread(target=self.read_camera_frames)
             self.read_images_thread.daemon = True
             self.read_images_thread.start()
         elif self.source_type == "data":
             self.read_images_thread = threading.Thread(target=self.read_images_from_directory)
             self.read_images_thread.daemon = True
             self.read_images_thread.start()
         else:
             logging.error("Invalid source type. Please check the config.")
             self.running = False
 

     def stop_capture(self):
         """Stop image capture."""
         logging.info("Capture stopped.")
         self.running = False
         if self.source_type == "camera":
             if hasattr(self, 'capture') and self.capture is not None:
                 self.capture.release()
         elif self.source_type == "data":
             if self.read_images_thread is not None:
                 self.read_images_thread.join()
         self.image_queue = None
         self.db = None
 

     def read_camera_frames(self):
         """Reads frames from the camera, saves them, and puts them in the queue with a 30-second interval, checking for uniqueness."""
         while self.running:
             current_time = time.time()
             if current_time - self.last_capture_time >= self.capture_interval:
                 ret, frame = self.capture.read()
                 if not ret or frame is None:
                     logging.warning("Failed to capture frame from camera.")
                     time.sleep(0.1)
                     continue
                 timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                 image_path = os.path.join(self.data_dir, f"{timestamp}.jpg")
                 cv2.imwrite(image_path, frame)
                 image_hash = self.calculate_image_hash(image_path)
 

                 if not self.db.check_image_hash(image_hash):
                     try:
                         self.image_queue.put((frame, timestamp, image_hash), block=True, timeout=1)
                         logging.info(f"Image added to queue: {image_path}, hash: {image_hash}")
                     except queue.Full:
                         logging.warning("Queue is full. Skipping frame.")
                     self.last_capture_time = current_time
                     self.db.insert_image_hash(image_hash)
                 else:
                     logging.info(f"Image already processed, skipping: {image_path}, hash: {image_hash}")
             else:
                 time.sleep(1)
 

     def read_images_from_directory(self):
         """Reads images from the directory, checks hash, and puts them in the queue."""
         image_dir = self.config.image_source
         image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
         logging.info(f"Found {len(image_files)} image files in {image_dir}")
         while self.running:
             for image_file in image_files:
                 if not self.running:
                     break
                 image_path = os.path.join(image_dir, image_file)
                 image_hash = self.calculate_image_hash(image_path)
                 if not self.db.check_image_hash(image_hash):
                     logging.info(f"Reading image: {image_path}")
                     frame = cv2.imread(image_path)
                     if frame is None:
                         logging.error(f"Failed to read image {image_path}")
                         continue
                     timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                     try:
                         self.image_queue.put((frame, timestamp, image_hash), block=True, timeout=1)
                         logging.info(f"Image added to queue: {image_path}")
                     except queue.Full:
                         logging.warning("Queue is full. Skipping image.")
                     time.sleep(0.1)
                 else:
                     logging.info(f"Image already processed: {image_path}, hash: {image_hash}")
                     continue
             time.sleep(60)
         logging.info("Finished reading images from directory.")
 

     def calculate_image_hash(self, image_path):
         """Calculate the MD5 hash of the image file."""
         hasher = hashlib.md5()
         try:
             with open(image_path, 'rb') as image_file:
                 buf = image_file.read()
                 hasher.update(buf)
             return hasher.hexdigest()
         except Exception as e:
             logging.error(f"Error calculating image hash for {image_path}: {e}")
             return None
 

     def read_frame(self):
         """Reads a frame from the current source (camera or directory)."""
         if self.source_type == 'camera':
             ret, frame = self.capture.read()
             if ret:
                 return frame, True
             else:
                 return None, False
         return None, False
 

     def get_latest_frame(self):
         """Returns the latest frame from the active camera."""
         if self.source_type != 'camera' or not hasattr(self, 'capture'):
             return None, False
         return self.capture.read()
 

 # system.py
 import time
 import datetime
 import threading
 import queue
 import logging
 from config import Config
 from database import ViolationDatabase
 from detector import ViolationDetector
 from image_src import ImageSource
 

 class TrafficViolationSystem:
     def __init__(self, config: Config, image_queue: queue.Queue):
         self.config = config
         self.db = ViolationDatabase(config.db_path)
         self.detector = ViolationDetector(config.gemini_api_key, config.image_dir, config.input_shape, config.prompt)
         self.image_source = ImageSource(config)
         self.running = False
         self.image_queue = image_queue
         self.process_thread = None
         logging.basicConfig(level=logging.INFO)
 

     def start(self):
         if self.running:
             logging.info("System already running.")
             return
         self.running = True
         self.image_source.start_capture(self.image_queue, self.db)  # Pass the queue and db to image source
         logging.info("Image capture started.")
         self.process_thread = threading.Thread(target=self.process_images)
         self.process_thread.daemon = True
         self.process_thread.start()
         logging.info(f"Process thread started: {self.process_thread.is_alive()}")  # Check if thread is alive
         logging.info("System started. Press Ctrl+C to stop.")
         try:
             while self.running:
                 time.sleep(1)
         except KeyboardInterrupt:
             logging.info("Stopping system...")
             self.stop()
         finally:
             self.cleanup()
 

     def stop(self):
         self.running = False
         if self.process_thread:
             self.process_thread.join()
         self.image_source.stop_capture()
         self.db.close()
 

     def cleanup(self):
         self.image_source.stop_capture()
         self.db.close()
 

     def process_images(self):
         logging.info("Process images thread started.")  # Log thread start
         while self.running:
             try:
                 item = self.image_queue.get(timeout=1)
                 if len(item) == 3:
                     image, timestamp, image_hash = item
                 else:
                     image, timestamp = item
                     image_hash = None
 

                 if image is None:
                     logging.warning("Received None image from queue.")
                     self.image_queue.task_done()
                     continue